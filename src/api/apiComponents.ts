/* eslint-disable @typescript-eslint/no-empty-object-type */
/* eslint-disable @typescript-eslint/consistent-type-imports */
/**
 * Generated by @openapi-codegen
 *
 * @version 1.0
 */
import * as reactQuery from "@tanstack/react-query";
import { useApiContext, type ApiContext, queryKeyFn } from "./apiContext";
import { deepMerge } from "./apiUtils";
import type * as Fetcher from "./apiFetcher";
import { apiFetch } from "./apiFetcher";
import type * as Schemas from "./apiSchemas";

type QueryFnOptions = {
  signal?: AbortController["signal"];
};

export type GetUserProfilePathParams = {
  /**
   * @format int64
   */
  id: number;
};

export type GetUserProfileError = Fetcher.ErrorWrapper<undefined>;

export type GetUserProfileVariables = {
  pathParams: GetUserProfilePathParams;
} & ApiContext["fetcherOptions"];

export const fetchGetUserProfile = (
  variables: GetUserProfileVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.UserProfile,
    GetUserProfileError,
    undefined,
    {},
    {},
    GetUserProfilePathParams
  >({ url: "/user/{id}", method: "get", ...variables, signal });

export function getUserProfileQuery(variables: GetUserProfileVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.UserProfile>;
};

export function getUserProfileQuery(
  variables: GetUserProfileVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.UserProfile>)
    | reactQuery.SkipToken;
};

export function getUserProfileQuery(
  variables: GetUserProfileVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/user/{id}",
      operationId: "getUserProfile",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetUserProfile(variables, signal),
  };
}

export const useSuspenseGetUserProfile = <TData = Schemas.UserProfile>(
  variables: GetUserProfileVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.UserProfile, GetUserProfileError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.UserProfile,
    GetUserProfileError,
    TData
  >({
    ...getUserProfileQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetUserProfile = <TData = Schemas.UserProfile>(
  variables: GetUserProfileVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.UserProfile, GetUserProfileError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useQuery<Schemas.UserProfile, GetUserProfileError, TData>({
    ...getUserProfileQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type UpdateUserProfilePathParams = {
  /**
   * @format int64
   */
  id: number;
};

export type UpdateUserProfileError = Fetcher.ErrorWrapper<undefined>;

export type UpdateUserProfileRequestBody = {
  /**
   * @format binary
   */
  files: Blob;
  body: Schemas.UserProfileDTO;
};

export type UpdateUserProfileVariables = {
  body: UpdateUserProfileRequestBody;
  pathParams: UpdateUserProfilePathParams;
} & ApiContext["fetcherOptions"];

export const fetchUpdateUserProfile = (
  variables: UpdateUserProfileVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    string,
    UpdateUserProfileError,
    UpdateUserProfileRequestBody,
    {},
    {},
    UpdateUserProfilePathParams
  >({ url: "/user/{id}", method: "put", ...variables, signal });

export const useUpdateUserProfile = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      string,
      UpdateUserProfileError,
      UpdateUserProfileVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    string,
    UpdateUserProfileError,
    UpdateUserProfileVariables
  >({
    mutationFn: (variables: UpdateUserProfileVariables) =>
      fetchUpdateUserProfile(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DeleteUserProfilePathParams = {
  /**
   * @format int64
   */
  id: number;
};

export type DeleteUserProfileError = Fetcher.ErrorWrapper<undefined>;

export type DeleteUserProfileVariables = {
  pathParams: DeleteUserProfilePathParams;
} & ApiContext["fetcherOptions"];

export const fetchDeleteUserProfile = (
  variables: DeleteUserProfileVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    undefined,
    DeleteUserProfileError,
    undefined,
    {},
    {},
    DeleteUserProfilePathParams
  >({ url: "/user/{id}", method: "delete", ...variables, signal });

export const useDeleteUserProfile = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteUserProfileError,
      DeleteUserProfileVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    undefined,
    DeleteUserProfileError,
    DeleteUserProfileVariables
  >({
    mutationFn: (variables: DeleteUserProfileVariables) =>
      fetchDeleteUserProfile(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetRecipePathParams = {
  /**
   * @format int64
   */
  id: number;
};

export type GetRecipeError = Fetcher.ErrorWrapper<undefined>;

export type GetRecipeVariables = {
  pathParams: GetRecipePathParams;
} & ApiContext["fetcherOptions"];

export const fetchGetRecipe = (
  variables: GetRecipeVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.RecipeDTO,
    GetRecipeError,
    undefined,
    {},
    {},
    GetRecipePathParams
  >({ url: "/api/recipe/{id}", method: "get", ...variables, signal });

export function getRecipeQuery(variables: GetRecipeVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.RecipeDTO>;
};

export function getRecipeQuery(
  variables: GetRecipeVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.RecipeDTO>)
    | reactQuery.SkipToken;
};

export function getRecipeQuery(
  variables: GetRecipeVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/recipe/{id}",
      operationId: "getRecipe",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetRecipe(variables, signal),
  };
}

export const useSuspenseGetRecipe = <TData = Schemas.RecipeDTO>(
  variables: GetRecipeVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.RecipeDTO, GetRecipeError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useSuspenseQuery<Schemas.RecipeDTO, GetRecipeError, TData>({
    ...getRecipeQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetRecipe = <TData = Schemas.RecipeDTO>(
  variables: GetRecipeVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.RecipeDTO, GetRecipeError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useQuery<Schemas.RecipeDTO, GetRecipeError, TData>({
    ...getRecipeQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type UpdateRecipePathParams = {
  /**
   * @format int64
   */
  id: number;
};

export type UpdateRecipeError = Fetcher.ErrorWrapper<undefined>;

export type UpdateRecipeRequestBody = {
  /**
   * @format binary
   */
  image: Blob;
  body: Schemas.RecipeDTO;
};

export type UpdateRecipeVariables = {
  body: UpdateRecipeRequestBody;
  pathParams: UpdateRecipePathParams;
} & ApiContext["fetcherOptions"];

export const fetchUpdateRecipe = (
  variables: UpdateRecipeVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    string,
    UpdateRecipeError,
    UpdateRecipeRequestBody,
    {},
    {},
    UpdateRecipePathParams
  >({ url: "/api/recipe/{id}", method: "put", ...variables, signal });

export const useUpdateRecipe = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      string,
      UpdateRecipeError,
      UpdateRecipeVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    string,
    UpdateRecipeError,
    UpdateRecipeVariables
  >({
    mutationFn: (variables: UpdateRecipeVariables) =>
      fetchUpdateRecipe(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DeleteRecipePathParams = {
  /**
   * @format int64
   */
  id: number;
};

export type DeleteRecipeError = Fetcher.ErrorWrapper<undefined>;

export type DeleteRecipeVariables = {
  pathParams: DeleteRecipePathParams;
} & ApiContext["fetcherOptions"];

export const fetchDeleteRecipe = (
  variables: DeleteRecipeVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    undefined,
    DeleteRecipeError,
    undefined,
    {},
    {},
    DeleteRecipePathParams
  >({ url: "/api/recipe/{id}", method: "delete", ...variables, signal });

export const useDeleteRecipe = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteRecipeError,
      DeleteRecipeVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    undefined,
    DeleteRecipeError,
    DeleteRecipeVariables
  >({
    mutationFn: (variables: DeleteRecipeVariables) =>
      fetchDeleteRecipe(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetAllUserProfilesError = Fetcher.ErrorWrapper<undefined>;

export type GetAllUserProfilesResponse = Schemas.UserProfile[];

export type GetAllUserProfilesVariables = ApiContext["fetcherOptions"];

export const fetchGetAllUserProfiles = (
  variables: GetAllUserProfilesVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    GetAllUserProfilesResponse,
    GetAllUserProfilesError,
    undefined,
    {},
    {},
    {}
  >({ url: "/user/", method: "get", ...variables, signal });

export function getAllUserProfilesQuery(
  variables: GetAllUserProfilesVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetAllUserProfilesResponse>;
};

export function getAllUserProfilesQuery(
  variables: GetAllUserProfilesVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetAllUserProfilesResponse>)
    | reactQuery.SkipToken;
};

export function getAllUserProfilesQuery(
  variables: GetAllUserProfilesVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/user/",
      operationId: "getAllUserProfiles",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetAllUserProfiles(variables, signal),
  };
}

export const useSuspenseGetAllUserProfiles = <
  TData = GetAllUserProfilesResponse,
>(
  variables: GetAllUserProfilesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetAllUserProfilesResponse,
      GetAllUserProfilesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useSuspenseQuery<
    GetAllUserProfilesResponse,
    GetAllUserProfilesError,
    TData
  >({
    ...getAllUserProfilesQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetAllUserProfiles = <TData = GetAllUserProfilesResponse>(
  variables: GetAllUserProfilesVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetAllUserProfilesResponse,
      GetAllUserProfilesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useQuery<
    GetAllUserProfilesResponse,
    GetAllUserProfilesError,
    TData
  >({
    ...getAllUserProfilesQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type SaveUserProfileError = Fetcher.ErrorWrapper<undefined>;

export type SaveUserProfileRequestBody = {
  /**
   * @format binary
   */
  files: Blob;
  body: Schemas.UserProfileDTO;
};

export type SaveUserProfileVariables = {
  body: SaveUserProfileRequestBody;
} & ApiContext["fetcherOptions"];

export const fetchSaveUserProfile = (
  variables: SaveUserProfileVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    string,
    SaveUserProfileError,
    SaveUserProfileRequestBody,
    {},
    {},
    {}
  >({ url: "/user/", method: "post", ...variables, signal });

export const useSaveUserProfile = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      string,
      SaveUserProfileError,
      SaveUserProfileVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    string,
    SaveUserProfileError,
    SaveUserProfileVariables
  >({
    mutationFn: (variables: SaveUserProfileVariables) =>
      fetchSaveUserProfile(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type SaveImageError = Fetcher.ErrorWrapper<undefined>;

export type SaveImageRequestBody = {
  /**
   * @format binary
   */
  image: Blob;
};

export type SaveImageVariables = {
  body: SaveImageRequestBody;
} & ApiContext["fetcherOptions"];

export const fetchSaveImage = (
  variables: SaveImageVariables,
  signal?: AbortSignal,
) =>
  apiFetch<string, SaveImageError, SaveImageRequestBody, {}, {}, {}>({
    url: "/api/recipe/images",
    method: "post",
    ...variables,
    signal,
  });

export const useSaveImage = (
  options?: Omit<
    reactQuery.UseMutationOptions<string, SaveImageError, SaveImageVariables>,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<string, SaveImageError, SaveImageVariables>({
    mutationFn: (variables: SaveImageVariables) =>
      fetchSaveImage(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetAllRecipesError = Fetcher.ErrorWrapper<undefined>;

export type GetAllRecipesResponse = Schemas.RecipeDTO[];

export type GetAllRecipesVariables = ApiContext["fetcherOptions"];

export const fetchGetAllRecipes = (
  variables: GetAllRecipesVariables,
  signal?: AbortSignal,
) =>
  apiFetch<GetAllRecipesResponse, GetAllRecipesError, undefined, {}, {}, {}>({
    url: "/api/recipe/",
    method: "get",
    ...variables,
    signal,
  });

export function getAllRecipesQuery(variables: GetAllRecipesVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetAllRecipesResponse>;
};

export function getAllRecipesQuery(
  variables: GetAllRecipesVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetAllRecipesResponse>)
    | reactQuery.SkipToken;
};

export function getAllRecipesQuery(
  variables: GetAllRecipesVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/recipe/",
      operationId: "getAllRecipes",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetAllRecipes(variables, signal),
  };
}

export const useSuspenseGetAllRecipes = <TData = GetAllRecipesResponse>(
  variables: GetAllRecipesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetAllRecipesResponse,
      GetAllRecipesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useSuspenseQuery<
    GetAllRecipesResponse,
    GetAllRecipesError,
    TData
  >({
    ...getAllRecipesQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetAllRecipes = <TData = GetAllRecipesResponse>(
  variables: GetAllRecipesVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetAllRecipesResponse,
      GetAllRecipesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useQuery<GetAllRecipesResponse, GetAllRecipesError, TData>({
    ...getAllRecipesQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type SaveRecipeError = Fetcher.ErrorWrapper<undefined>;

export type SaveRecipeRequestBody = {
  /**
   * @format binary
   */
  image: Blob;
  body: Schemas.RecipeDTO;
};

export type SaveRecipeVariables = {
  body: SaveRecipeRequestBody;
} & ApiContext["fetcherOptions"];

export const fetchSaveRecipe = (
  variables: SaveRecipeVariables,
  signal?: AbortSignal,
) =>
  apiFetch<string, SaveRecipeError, SaveRecipeRequestBody, {}, {}, {}>({
    url: "/api/recipe/",
    method: "post",
    ...variables,
    signal,
  });

export const useSaveRecipe = (
  options?: Omit<
    reactQuery.UseMutationOptions<string, SaveRecipeError, SaveRecipeVariables>,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<string, SaveRecipeError, SaveRecipeVariables>({
    mutationFn: (variables: SaveRecipeVariables) =>
      fetchSaveRecipe(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetUserProfileByKeycloakIdPathParams = {
  /**
   * @format int64
   */
  id: string;
};

export type GetUserProfileByKeycloakIdError = Fetcher.ErrorWrapper<undefined>;

export type GetUserProfileByKeycloakIdVariables = {
  pathParams: GetUserProfileByKeycloakIdPathParams;
} & ApiContext["fetcherOptions"];

export const fetchGetUserProfileByKeycloakId = (
  variables: GetUserProfileByKeycloakIdVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.UserProfile,
    GetUserProfileByKeycloakIdError,
    undefined,
    {},
    {},
    GetUserProfileByKeycloakIdPathParams
  >({ url: "/user/keycloak/{id}", method: "get", ...variables, signal });

export function getUserProfileByKeycloakIdQuery(
  variables: GetUserProfileByKeycloakIdVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.UserProfile>;
};

export function getUserProfileByKeycloakIdQuery(
  variables: GetUserProfileByKeycloakIdVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.UserProfile>)
    | reactQuery.SkipToken;
};

export function getUserProfileByKeycloakIdQuery(
  variables: GetUserProfileByKeycloakIdVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/user/keycloak/{id}",
      operationId: "getUserProfileByKeycloakId",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetUserProfileByKeycloakId(variables, signal),
  };
}

export const useSuspenseGetUserProfileByKeycloakId = <
  TData = Schemas.UserProfile,
>(
  variables: GetUserProfileByKeycloakIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.UserProfile,
      GetUserProfileByKeycloakIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.UserProfile,
    GetUserProfileByKeycloakIdError,
    TData
  >({
    ...getUserProfileByKeycloakIdQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetUserProfileByKeycloakId = <TData = Schemas.UserProfile>(
  variables: GetUserProfileByKeycloakIdVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.UserProfile,
      GetUserProfileByKeycloakIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.UserProfile,
    GetUserProfileByKeycloakIdError,
    TData
  >({
    ...getUserProfileByKeycloakIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetImagePathParams = {
  filename: string;
};

export type GetImageError = Fetcher.ErrorWrapper<undefined>;

export type GetImageVariables = {
  pathParams: GetImagePathParams;
} & ApiContext["fetcherOptions"];

export const fetchGetImage = (
  variables: GetImageVariables,
  signal?: AbortSignal,
) =>
  apiFetch<Blob, GetImageError, undefined, {}, {}, GetImagePathParams>({
    url: "/api/recipe/images/{filename}",
    method: "get",
    ...variables,
    signal,
  });

export function getImageQuery(variables: GetImageVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Blob>;
};

export function getImageQuery(
  variables: GetImageVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: ((options: QueryFnOptions) => Promise<Blob>) | reactQuery.SkipToken;
};

export function getImageQuery(
  variables: GetImageVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/recipe/images/{filename}",
      operationId: "getImage",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetImage(variables, signal),
  };
}

export const useSuspenseGetImage = <TData = Blob>(
  variables: GetImageVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Blob, GetImageError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useSuspenseQuery<Blob, GetImageError, TData>({
    ...getImageQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetImage = <TData = Blob>(
  variables: GetImageVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Blob, GetImageError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useQuery<Blob, GetImageError, TData>({
    ...getImageQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetImageV2PathParams = {
  filename: string;
};

export type GetImageV2Error = Fetcher.ErrorWrapper<undefined>;

export type GetImageV2Response = string[];

export type GetImageV2Variables = {
  pathParams: GetImageV2PathParams;
} & ApiContext["fetcherOptions"];

export const fetchGetImageV2 = (
  variables: GetImageV2Variables,
  signal?: AbortSignal,
) =>
  apiFetch<
    GetImageV2Response,
    GetImageV2Error,
    undefined,
    {},
    {},
    GetImageV2PathParams
  >({
    url: "/api/recipe/images/v2/{filename}",
    method: "get",
    ...variables,
    signal,
  });

export function getImageV2Query(variables: GetImageV2Variables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetImageV2Response>;
};

export function getImageV2Query(
  variables: GetImageV2Variables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetImageV2Response>)
    | reactQuery.SkipToken;
};

export function getImageV2Query(
  variables: GetImageV2Variables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/recipe/images/v2/{filename}",
      operationId: "getImageV2",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetImageV2(variables, signal),
  };
}

export const useSuspenseGetImageV2 = <TData = GetImageV2Response>(
  variables: GetImageV2Variables,
  options?: Omit<
    reactQuery.UseQueryOptions<GetImageV2Response, GetImageV2Error, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useSuspenseQuery<
    GetImageV2Response,
    GetImageV2Error,
    TData
  >({
    ...getImageV2Query(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetImageV2 = <TData = GetImageV2Response>(
  variables: GetImageV2Variables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<GetImageV2Response, GetImageV2Error, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useQuery<GetImageV2Response, GetImageV2Error, TData>({
    ...getImageV2Query(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type QueryOperation =
  | {
      path: "/user/{id}";
      operationId: "getUserProfile";
      variables: GetUserProfileVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/recipe/{id}";
      operationId: "getRecipe";
      variables: GetRecipeVariables | reactQuery.SkipToken;
    }
  | {
      path: "/user/";
      operationId: "getAllUserProfiles";
      variables: GetAllUserProfilesVariables | reactQuery.SkipToken;
    }
  | {
      path: "/user/keycloak/{id}";
      operationId: "getUserProfileByKeycloakId";
      variables: GetUserProfileByKeycloakIdVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/recipe/";
      operationId: "getAllRecipes";
      variables: GetAllRecipesVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/recipe/images/{filename}";
      operationId: "getImage";
      variables: GetImageVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/recipe/images/v2/{filename}";
      operationId: "getImageV2";
      variables: GetImageV2Variables | reactQuery.SkipToken;
    };
