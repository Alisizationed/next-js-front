/* eslint-disable @typescript-eslint/no-empty-object-type */
/**
 * Generated by @openapi-codegen
 *
 * @version 1.0
 */
import * as reactQuery from "@tanstack/react-query";
import { useApiContext, type ApiContext, queryKeyFn } from "./apiContext";
import { deepMerge } from "./apiUtils";
import type * as Fetcher from "./apiFetcher";
import { apiFetch } from "./apiFetcher";
import type * as Schemas from "./apiSchemas";

type QueryFnOptions = {
  signal?: AbortController["signal"];
};

export type GetRecipePathParams = {
  /**
   * @format int64
   */
  id: number;
};

export type GetRecipeError = Fetcher.ErrorWrapper<undefined>;

export type GetRecipeVariables = {
  pathParams: GetRecipePathParams;
} & ApiContext["fetcherOptions"];

export const fetchGetRecipe = (
  variables: GetRecipeVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.RecipeDTO,
    GetRecipeError,
    undefined,
    {},
    {},
    GetRecipePathParams
  >({ url: "/api/recipe/{id}", method: "get", ...variables, signal });

export function getRecipeQuery(variables: GetRecipeVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.RecipeDTO>;
};

export function getRecipeQuery(
  variables: GetRecipeVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.RecipeDTO>)
    | reactQuery.SkipToken;
};

export function getRecipeQuery(
  variables: GetRecipeVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/recipe/{id}",
      operationId: "getRecipe",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetRecipe(variables, signal),
  };
}

export const useSuspenseGetRecipe = <TData = Schemas.RecipeDTO,>(
  variables: GetRecipeVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.RecipeDTO, GetRecipeError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useSuspenseQuery<Schemas.RecipeDTO, GetRecipeError, TData>({
    ...getRecipeQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetRecipe = <TData = Schemas.RecipeDTO,>(
  variables: GetRecipeVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.RecipeDTO, GetRecipeError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useQuery<Schemas.RecipeDTO, GetRecipeError, TData>({
    ...getRecipeQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type UpdateRecipePathParams = {
  /**
   * @format int64
   */
  id: number;
};

export type UpdateRecipeError = Fetcher.ErrorWrapper<undefined>;

export type UpdateRecipeRequestBody = {
  /**
   * @format binary
   */
  image?: Blob;
  body: Schemas.RecipeDTO;
};

export type UpdateRecipeVariables = {
  body: UpdateRecipeRequestBody;
  pathParams: UpdateRecipePathParams;
} & ApiContext["fetcherOptions"];

export const fetchUpdateRecipe = (
  variables: UpdateRecipeVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    string,
    UpdateRecipeError,
    UpdateRecipeRequestBody,
    {},
    {},
    UpdateRecipePathParams
  >({ url: "/api/recipe/{id}", method: "put", ...variables, signal });

export const useUpdateRecipe = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      string,
      UpdateRecipeError,
      UpdateRecipeVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    string,
    UpdateRecipeError,
    UpdateRecipeVariables
  >({
    mutationFn: (variables: UpdateRecipeVariables) =>
      fetchUpdateRecipe(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DeleteRecipePathParams = {
  /**
   * @format int64
   */
  id: number;
};

export type DeleteRecipeError = Fetcher.ErrorWrapper<undefined>;

export type DeleteRecipeVariables = {
  pathParams: DeleteRecipePathParams;
} & ApiContext["fetcherOptions"];

export const fetchDeleteRecipe = (
  variables: DeleteRecipeVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    undefined,
    DeleteRecipeError,
    undefined,
    {},
    {},
    DeleteRecipePathParams
  >({ url: "/api/recipe/{id}", method: "delete", ...variables, signal });

export const useDeleteRecipe = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteRecipeError,
      DeleteRecipeVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<
    undefined,
    DeleteRecipeError,
    DeleteRecipeVariables
  >({
    mutationFn: (variables: DeleteRecipeVariables) =>
      fetchDeleteRecipe(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type SaveImageError = Fetcher.ErrorWrapper<undefined>;

export type SaveImageRequestBody = {
  /**
   * @format binary
   */
  image: Blob;
};

export type SaveImageVariables = {
  body: SaveImageRequestBody;
} & ApiContext["fetcherOptions"];

export const fetchSaveImage = (
  variables: SaveImageVariables,
  signal?: AbortSignal,
) =>
  apiFetch<string, SaveImageError, SaveImageRequestBody, {}, {}, {}>({
    url: "/api/recipe/images",
    method: "post",
    ...variables,
    signal,
  });

export const useSaveImage = (
  options?: Omit<
    reactQuery.UseMutationOptions<string, SaveImageError, SaveImageVariables>,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<string, SaveImageError, SaveImageVariables>({
    mutationFn: (variables: SaveImageVariables) =>
      fetchSaveImage(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetAllRecipesError = Fetcher.ErrorWrapper<undefined>;

export type GetAllRecipesResponse = Schemas.ShortRecipeDTO[];

export type GetAllRecipesVariables = ApiContext["fetcherOptions"];

export const fetchGetAllRecipes = (
  variables: GetAllRecipesVariables,
  signal?: AbortSignal,
) =>
  apiFetch<GetAllRecipesResponse, GetAllRecipesError, undefined, {}, {}, {}>({
    url: "/api/recipe/",
    method: "get",
    ...variables,
    signal,
  });

export function getAllRecipesQuery(variables: GetAllRecipesVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetAllRecipesResponse>;
};

export function getAllRecipesQuery(
  variables: GetAllRecipesVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetAllRecipesResponse>)
    | reactQuery.SkipToken;
};

export function getAllRecipesQuery(
  variables: GetAllRecipesVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/recipe/",
      operationId: "getAllRecipes",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetAllRecipes(variables, signal),
  };
}

export const useSuspenseGetAllRecipes = <TData = GetAllRecipesResponse,>(
  variables: GetAllRecipesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetAllRecipesResponse,
      GetAllRecipesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useSuspenseQuery<
    GetAllRecipesResponse,
    GetAllRecipesError,
    TData
  >({
    ...getAllRecipesQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetAllRecipes = <TData = GetAllRecipesResponse,>(
  variables: GetAllRecipesVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetAllRecipesResponse,
      GetAllRecipesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useQuery<GetAllRecipesResponse, GetAllRecipesError, TData>({
    ...getAllRecipesQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type SaveRecipeError = Fetcher.ErrorWrapper<undefined>;

export type SaveRecipeRequestBody = {
  /**
   * @format binary
   */
  image: Blob;
  body: string;
};

export type SaveRecipeVariables = {
  body: SaveRecipeRequestBody;
} & ApiContext["fetcherOptions"];

export const fetchSaveRecipe = (
  variables: SaveRecipeVariables,
  signal?: AbortSignal,
) =>
  apiFetch<string, SaveRecipeError, SaveRecipeRequestBody, {}, {}, {}>({
    url: "/api/recipe/",
    method: "post",
    ...variables,
    signal,
  });

export const useSaveRecipe = (
  options?: Omit<
    reactQuery.UseMutationOptions<string, SaveRecipeError, SaveRecipeVariables>,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApiContext();
  return reactQuery.useMutation<string, SaveRecipeError, SaveRecipeVariables>({
    mutationFn: (variables: SaveRecipeVariables) =>
      fetchSaveRecipe(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetAllUsersRecipesPathParams = {
  id: string;
};

export type GetAllUsersRecipesError = Fetcher.ErrorWrapper<undefined>;

export type GetAllUsersRecipesResponse = Schemas.ShortRecipeDTO[];

export type GetAllUsersRecipesVariables = {
  pathParams: GetAllUsersRecipesPathParams;
} & ApiContext["fetcherOptions"];

export const fetchGetAllUsersRecipes = (
  variables: GetAllUsersRecipesVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    GetAllUsersRecipesResponse,
    GetAllUsersRecipesError,
    undefined,
    {},
    {},
    GetAllUsersRecipesPathParams
  >({ url: "/api/recipe/user/{id}", method: "get", ...variables, signal });

export function getAllUsersRecipesQuery(
  variables: GetAllUsersRecipesVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetAllUsersRecipesResponse>;
};

export function getAllUsersRecipesQuery(
  variables: GetAllUsersRecipesVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetAllUsersRecipesResponse>)
    | reactQuery.SkipToken;
};

export function getAllUsersRecipesQuery(
  variables: GetAllUsersRecipesVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/recipe/user/{id}",
      operationId: "getAllUsersRecipes",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetAllUsersRecipes(variables, signal),
  };
}

export const useSuspenseGetAllUsersRecipes = <
  TData = GetAllUsersRecipesResponse,
>(
  variables: GetAllUsersRecipesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetAllUsersRecipesResponse,
      GetAllUsersRecipesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useSuspenseQuery<
    GetAllUsersRecipesResponse,
    GetAllUsersRecipesError,
    TData
  >({
    ...getAllUsersRecipesQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetAllUsersRecipes = <TData = GetAllUsersRecipesResponse,>(
  variables: GetAllUsersRecipesVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetAllUsersRecipesResponse,
      GetAllUsersRecipesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useQuery<
    GetAllUsersRecipesResponse,
    GetAllUsersRecipesError,
    TData
  >({
    ...getAllUsersRecipesQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetRecommendedRecipesPathParams = {
  /**
   * @format int64
   */
  id: number;
  /**
   * @format int64
   */
  limit: number;
};

export type GetRecommendedRecipesError = Fetcher.ErrorWrapper<undefined>;

export type GetRecommendedRecipesResponse = Schemas.RecipeDTO[];

export type GetRecommendedRecipesVariables = {
  pathParams: GetRecommendedRecipesPathParams;
} & ApiContext["fetcherOptions"];

export const fetchGetRecommendedRecipes = (
  variables: GetRecommendedRecipesVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    GetRecommendedRecipesResponse,
    GetRecommendedRecipesError,
    undefined,
    {},
    {},
    GetRecommendedRecipesPathParams
  >({
    url: "/api/recipe/recommended/{id}/{limit}",
    method: "get",
    ...variables,
    signal,
  });

export function getRecommendedRecipesQuery(
  variables: GetRecommendedRecipesVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetRecommendedRecipesResponse>;
};

export function getRecommendedRecipesQuery(
  variables: GetRecommendedRecipesVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetRecommendedRecipesResponse>)
    | reactQuery.SkipToken;
};

export function getRecommendedRecipesQuery(
  variables: GetRecommendedRecipesVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/recipe/recommended/{id}/{limit}",
      operationId: "getRecommendedRecipes",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetRecommendedRecipes(variables, signal),
  };
}

export const useSuspenseGetRecommendedRecipes = <
  TData = GetRecommendedRecipesResponse,
>(
  variables: GetRecommendedRecipesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetRecommendedRecipesResponse,
      GetRecommendedRecipesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useSuspenseQuery<
    GetRecommendedRecipesResponse,
    GetRecommendedRecipesError,
    TData
  >({
    ...getRecommendedRecipesQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetRecommendedRecipes = <
  TData = GetRecommendedRecipesResponse,
>(
  variables: GetRecommendedRecipesVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetRecommendedRecipesResponse,
      GetRecommendedRecipesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useQuery<
    GetRecommendedRecipesResponse,
    GetRecommendedRecipesError,
    TData
  >({
    ...getRecommendedRecipesQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetAllRecipesPageableQueryParams = {
  /**
   * @format int64
   */
  page: number;
  /**
   * @format int64
   */
  size: number;
};

export type GetAllRecipesPageableError = Fetcher.ErrorWrapper<undefined>;

export type GetAllRecipesPageableResponse = Schemas.ShortRecipeDTO[];

export type GetAllRecipesPageableVariables = {
  queryParams: GetAllRecipesPageableQueryParams;
} & ApiContext["fetcherOptions"];

export const fetchGetAllRecipesPageable = (
  variables: GetAllRecipesPageableVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    GetAllRecipesPageableResponse,
    GetAllRecipesPageableError,
    undefined,
    {},
    GetAllRecipesPageableQueryParams,
    {}
  >({ url: "/api/recipe/pageable", method: "get", ...variables, signal });

export function getAllRecipesPageableQuery(
  variables: GetAllRecipesPageableVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetAllRecipesPageableResponse>;
};

export function getAllRecipesPageableQuery(
  variables: GetAllRecipesPageableVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetAllRecipesPageableResponse>)
    | reactQuery.SkipToken;
};

export function getAllRecipesPageableQuery(
  variables: GetAllRecipesPageableVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/recipe/pageable",
      operationId: "getAllRecipesPageable",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetAllRecipesPageable(variables, signal),
  };
}

export const useSuspenseGetAllRecipesPageable = <
  TData = GetAllRecipesPageableResponse,
>(
  variables: GetAllRecipesPageableVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetAllRecipesPageableResponse,
      GetAllRecipesPageableError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useSuspenseQuery<
    GetAllRecipesPageableResponse,
    GetAllRecipesPageableError,
    TData
  >({
    ...getAllRecipesPageableQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetAllRecipesPageable = <
  TData = GetAllRecipesPageableResponse,
>(
  variables: GetAllRecipesPageableVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetAllRecipesPageableResponse,
      GetAllRecipesPageableError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useQuery<
    GetAllRecipesPageableResponse,
    GetAllRecipesPageableError,
    TData
  >({
    ...getAllRecipesPageableQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetAllRecipesPageableV2QueryParams = {
  /**
   * @format int32
   */
  page: number;
  /**
   * @format int32
   */
  size: number;
};

export type GetAllRecipesPageableV2Error = Fetcher.ErrorWrapper<undefined>;

export type GetAllRecipesPageableV2Variables = {
  queryParams: GetAllRecipesPageableV2QueryParams;
} & ApiContext["fetcherOptions"];

export const fetchGetAllRecipesPageableV2 = (
  variables: GetAllRecipesPageableV2Variables,
  signal?: AbortSignal,
) =>
  apiFetch<
    Schemas.PageImpl,
    GetAllRecipesPageableV2Error,
    undefined,
    {},
    GetAllRecipesPageableV2QueryParams,
    {}
  >({ url: "/api/recipe/pageable/v2", method: "get", ...variables, signal });

export function getAllRecipesPageableV2Query(
  variables: GetAllRecipesPageableV2Variables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.PageImpl>;
};

export function getAllRecipesPageableV2Query(
  variables: GetAllRecipesPageableV2Variables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.PageImpl>)
    | reactQuery.SkipToken;
};

export function getAllRecipesPageableV2Query(
  variables: GetAllRecipesPageableV2Variables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/recipe/pageable/v2",
      operationId: "getAllRecipesPageableV2",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetAllRecipesPageableV2(variables, signal),
  };
}

export const useSuspenseGetAllRecipesPageableV2 = <TData = Schemas.PageImpl,>(
  variables: GetAllRecipesPageableV2Variables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.PageImpl,
      GetAllRecipesPageableV2Error,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.PageImpl,
    GetAllRecipesPageableV2Error,
    TData
  >({
    ...getAllRecipesPageableV2Query(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetAllRecipesPageableV2 = <TData = Schemas.PageImpl,>(
  variables: GetAllRecipesPageableV2Variables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.PageImpl,
      GetAllRecipesPageableV2Error,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useQuery<
    Schemas.PageImpl,
    GetAllRecipesPageableV2Error,
    TData
  >({
    ...getAllRecipesPageableV2Query(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetImagePathParams = {
  filename: string;
};

export type GetImageError = Fetcher.ErrorWrapper<undefined>;

export type GetImageVariables = {
  pathParams: GetImagePathParams;
} & ApiContext["fetcherOptions"];

export const fetchGetImage = (
  variables: GetImageVariables,
  signal?: AbortSignal,
) =>
  apiFetch<Blob, GetImageError, undefined, {}, {}, GetImagePathParams>({
    url: "/api/recipe/images/{filename}",
    method: "get",
    ...variables,
    signal,
  });

export function getImageQuery(variables: GetImageVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Blob>;
};

export function getImageQuery(
  variables: GetImageVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: ((options: QueryFnOptions) => Promise<Blob>) | reactQuery.SkipToken;
};

export function getImageQuery(
  variables: GetImageVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/recipe/images/{filename}",
      operationId: "getImage",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetImage(variables, signal),
  };
}

export const useSuspenseGetImage = <TData = Blob,>(
  variables: GetImageVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Blob, GetImageError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useSuspenseQuery<Blob, GetImageError, TData>({
    ...getImageQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetImage = <TData = Blob,>(
  variables: GetImageVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Blob, GetImageError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useQuery<Blob, GetImageError, TData>({
    ...getImageQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetImageV2PathParams = {
  filename: string;
};

export type GetImageV2Error = Fetcher.ErrorWrapper<undefined>;

export type GetImageV2Response = string[];

export type GetImageV2Variables = {
  pathParams: GetImageV2PathParams;
} & ApiContext["fetcherOptions"];

export const fetchGetImageV2 = (
  variables: GetImageV2Variables,
  signal?: AbortSignal,
) =>
  apiFetch<
    GetImageV2Response,
    GetImageV2Error,
    undefined,
    {},
    {},
    GetImageV2PathParams
  >({
    url: "/api/recipe/images/v2/{filename}",
    method: "get",
    ...variables,
    signal,
  });

export function getImageV2Query(variables: GetImageV2Variables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetImageV2Response>;
};

export function getImageV2Query(
  variables: GetImageV2Variables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetImageV2Response>)
    | reactQuery.SkipToken;
};

export function getImageV2Query(
  variables: GetImageV2Variables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/recipe/images/v2/{filename}",
      operationId: "getImageV2",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetImageV2(variables, signal),
  };
}

export const useSuspenseGetImageV2 = <TData = GetImageV2Response,>(
  variables: GetImageV2Variables,
  options?: Omit<
    reactQuery.UseQueryOptions<GetImageV2Response, GetImageV2Error, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useSuspenseQuery<
    GetImageV2Response,
    GetImageV2Error,
    TData
  >({
    ...getImageV2Query(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetImageV2 = <TData = GetImageV2Response,>(
  variables: GetImageV2Variables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<GetImageV2Response, GetImageV2Error, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useQuery<GetImageV2Response, GetImageV2Error, TData>({
    ...getImageV2Query(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetFavouriteRecipesPathParams = {
  id: string;
};

export type GetFavouriteRecipesError = Fetcher.ErrorWrapper<undefined>;

export type GetFavouriteRecipesResponse = Schemas.ShortRecipeDTO[];

export type GetFavouriteRecipesVariables = {
  pathParams: GetFavouriteRecipesPathParams;
} & ApiContext["fetcherOptions"];

export const fetchGetFavouriteRecipes = (
  variables: GetFavouriteRecipesVariables,
  signal?: AbortSignal,
) =>
  apiFetch<
    GetFavouriteRecipesResponse,
    GetFavouriteRecipesError,
    undefined,
    {},
    {},
    GetFavouriteRecipesPathParams
  >({
    url: "/api/recipe/favourites/{id}",
    method: "get",
    ...variables,
    signal,
  });

export function getFavouriteRecipesQuery(
  variables: GetFavouriteRecipesVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetFavouriteRecipesResponse>;
};

export function getFavouriteRecipesQuery(
  variables: GetFavouriteRecipesVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetFavouriteRecipesResponse>)
    | reactQuery.SkipToken;
};

export function getFavouriteRecipesQuery(
  variables: GetFavouriteRecipesVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/recipe/favourites/{id}",
      operationId: "getFavouriteRecipes",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetFavouriteRecipes(variables, signal),
  };
}

export const useSuspenseGetFavouriteRecipes = <
  TData = GetFavouriteRecipesResponse,
>(
  variables: GetFavouriteRecipesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetFavouriteRecipesResponse,
      GetFavouriteRecipesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useSuspenseQuery<
    GetFavouriteRecipesResponse,
    GetFavouriteRecipesError,
    TData
  >({
    ...getFavouriteRecipesQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetFavouriteRecipes = <TData = GetFavouriteRecipesResponse,>(
  variables: GetFavouriteRecipesVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetFavouriteRecipesResponse,
      GetFavouriteRecipesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useQuery<
    GetFavouriteRecipesResponse,
    GetFavouriteRecipesError,
    TData
  >({
    ...getFavouriteRecipesQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetAllRecipesCountError = Fetcher.ErrorWrapper<undefined>;

export type GetAllRecipesCountVariables = ApiContext["fetcherOptions"];

export const fetchGetAllRecipesCount = (
  variables: GetAllRecipesCountVariables,
  signal?: AbortSignal,
) =>
  apiFetch<number, GetAllRecipesCountError, undefined, {}, {}, {}>({
    url: "/api/recipe/count",
    method: "get",
    ...variables,
    signal,
  });

export function getAllRecipesCountQuery(
  variables: GetAllRecipesCountVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<number>;
};

export function getAllRecipesCountQuery(
  variables: GetAllRecipesCountVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<number>)
    | reactQuery.SkipToken;
};

export function getAllRecipesCountQuery(
  variables: GetAllRecipesCountVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/recipe/count",
      operationId: "getAllRecipesCount",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetAllRecipesCount(variables, signal),
  };
}

export const useSuspenseGetAllRecipesCount = <TData = number,>(
  variables: GetAllRecipesCountVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<number, GetAllRecipesCountError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useSuspenseQuery<number, GetAllRecipesCountError, TData>({
    ...getAllRecipesCountQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetAllRecipesCount = <TData = number,>(
  variables: GetAllRecipesCountVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<number, GetAllRecipesCountError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApiContext(options);
  return reactQuery.useQuery<number, GetAllRecipesCountError, TData>({
    ...getAllRecipesCountQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type QueryOperation =
  | {
      path: "/api/recipe/{id}";
      operationId: "getRecipe";
      variables: GetRecipeVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/recipe/";
      operationId: "getAllRecipes";
      variables: GetAllRecipesVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/recipe/user/{id}";
      operationId: "getAllUsersRecipes";
      variables: GetAllUsersRecipesVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/recipe/recommended/{id}/{limit}";
      operationId: "getRecommendedRecipes";
      variables: GetRecommendedRecipesVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/recipe/pageable";
      operationId: "getAllRecipesPageable";
      variables: GetAllRecipesPageableVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/recipe/pageable/v2";
      operationId: "getAllRecipesPageableV2";
      variables: GetAllRecipesPageableV2Variables | reactQuery.SkipToken;
    }
  | {
      path: "/api/recipe/images/{filename}";
      operationId: "getImage";
      variables: GetImageVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/recipe/images/v2/{filename}";
      operationId: "getImageV2";
      variables: GetImageV2Variables | reactQuery.SkipToken;
    }
  | {
      path: "/api/recipe/favourites/{id}";
      operationId: "getFavouriteRecipes";
      variables: GetFavouriteRecipesVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/recipe/count";
      operationId: "getAllRecipesCount";
      variables: GetAllRecipesCountVariables | reactQuery.SkipToken;
    };
