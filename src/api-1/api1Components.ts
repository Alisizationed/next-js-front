/* eslint-disable @typescript-eslint/no-empty-object-type */
/**
 * Generated by @openapi-codegen
 *
 * @version 1.0
 */
import * as reactQuery from "@tanstack/react-query";
import { useApi1Context, type Api1Context, queryKeyFn } from "./api1Context";
import { deepMerge } from "./api1Utils";
import type * as Fetcher from "./api1Fetcher";
import { api1Fetch } from "./api1Fetcher";
import type * as Schemas from "./api1Schemas";

type QueryFnOptions = {
  signal?: AbortController["signal"];
};

export type IsFavouritePathParams = {
  id: string;
  /**
   * @format int64
   */
  favourite: number;
};

export type IsFavouriteError = Fetcher.ErrorWrapper<undefined>;

export type IsFavouriteVariables = {
  pathParams: IsFavouritePathParams;
} & Api1Context["fetcherOptions"];

export const fetchIsFavourite = (
  variables: IsFavouriteVariables,
  signal?: AbortSignal,
) =>
  api1Fetch<
    boolean,
    IsFavouriteError,
    undefined,
    {},
    {},
    IsFavouritePathParams
  >({
    url: "/api/users/favourite/{id}/{favourite}",
    method: "get",
    ...variables,
    signal,
  });

export function isFavouriteQuery(variables: IsFavouriteVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<boolean>;
};

export function isFavouriteQuery(
  variables: IsFavouriteVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<boolean>)
    | reactQuery.SkipToken;
};

export function isFavouriteQuery(
  variables: IsFavouriteVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/users/favourite/{id}/{favourite}",
      operationId: "isFavourite",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchIsFavourite(variables, signal),
  };
}

export const useSuspenseIsFavourite = <TData = boolean,>(
  variables: IsFavouriteVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<boolean, IsFavouriteError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApi1Context(options);
  return reactQuery.useSuspenseQuery<boolean, IsFavouriteError, TData>({
    ...isFavouriteQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useIsFavourite = <TData = boolean,>(
  variables: IsFavouriteVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<boolean, IsFavouriteError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApi1Context(options);
  return reactQuery.useQuery<boolean, IsFavouriteError, TData>({
    ...isFavouriteQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type SetIsFavouritePathParams = {
  id: string;
  /**
   * @format int64
   */
  favourite: number;
};

export type SetIsFavouriteQueryParams = {
  favouriteStatus: boolean;
};

export type SetIsFavouriteError = Fetcher.ErrorWrapper<undefined>;

export type SetIsFavouriteVariables = {
  pathParams: SetIsFavouritePathParams;
  queryParams: SetIsFavouriteQueryParams;
} & Api1Context["fetcherOptions"];

export const fetchSetIsFavourite = (
  variables: SetIsFavouriteVariables,
  signal?: AbortSignal,
) =>
  api1Fetch<
    undefined,
    SetIsFavouriteError,
    undefined,
    {},
    SetIsFavouriteQueryParams,
    SetIsFavouritePathParams
  >({
    url: "/api/users/favourite/{id}/{favourite}",
    method: "post",
    ...variables,
    signal,
  });

export const useSetIsFavourite = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      SetIsFavouriteError,
      SetIsFavouriteVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useApi1Context();
  return reactQuery.useMutation<
    undefined,
    SetIsFavouriteError,
    SetIsFavouriteVariables
  >({
    mutationFn: (variables: SetIsFavouriteVariables) =>
      fetchSetIsFavourite(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetAllUsersError = Fetcher.ErrorWrapper<undefined>;

export type GetAllUsersResponse = Schemas.UserListRepresentationDTO[];

export type GetAllUsersVariables = Api1Context["fetcherOptions"];

export const fetchGetAllUsers = (
  variables: GetAllUsersVariables,
  signal?: AbortSignal,
) =>
  api1Fetch<GetAllUsersResponse, GetAllUsersError, undefined, {}, {}, {}>({
    url: "/api/users",
    method: "get",
    ...variables,
    signal,
  });

export function getAllUsersQuery(variables: GetAllUsersVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetAllUsersResponse>;
};

export function getAllUsersQuery(
  variables: GetAllUsersVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetAllUsersResponse>)
    | reactQuery.SkipToken;
};

export function getAllUsersQuery(
  variables: GetAllUsersVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/users",
      operationId: "getAllUsers",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetAllUsers(variables, signal),
  };
}

export const useSuspenseGetAllUsers = <TData = GetAllUsersResponse,>(
  variables: GetAllUsersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<GetAllUsersResponse, GetAllUsersError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApi1Context(options);
  return reactQuery.useSuspenseQuery<
    GetAllUsersResponse,
    GetAllUsersError,
    TData
  >({
    ...getAllUsersQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetAllUsers = <TData = GetAllUsersResponse,>(
  variables: GetAllUsersVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<GetAllUsersResponse, GetAllUsersError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApi1Context(options);
  return reactQuery.useQuery<GetAllUsersResponse, GetAllUsersError, TData>({
    ...getAllUsersQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetUserByIdPathParams = {
  id: string;
};

export type GetUserByIdError = Fetcher.ErrorWrapper<undefined>;

export type GetUserByIdVariables = {
  pathParams: GetUserByIdPathParams;
} & Api1Context["fetcherOptions"];

export const fetchGetUserById = (
  variables: GetUserByIdVariables,
  signal?: AbortSignal,
) =>
  api1Fetch<
    Schemas.UserPublicRepresentationDTO,
    GetUserByIdError,
    undefined,
    {},
    {},
    GetUserByIdPathParams
  >({ url: "/api/users/{id}", method: "get", ...variables, signal });

export function getUserByIdQuery(variables: GetUserByIdVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<Schemas.UserPublicRepresentationDTO>;
};

export function getUserByIdQuery(
  variables: GetUserByIdVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<Schemas.UserPublicRepresentationDTO>)
    | reactQuery.SkipToken;
};

export function getUserByIdQuery(
  variables: GetUserByIdVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/users/{id}",
      operationId: "getUserById",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetUserById(variables, signal),
  };
}

export const useSuspenseGetUserById = <
  TData = Schemas.UserPublicRepresentationDTO,
>(
  variables: GetUserByIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.UserPublicRepresentationDTO,
      GetUserByIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApi1Context(options);
  return reactQuery.useSuspenseQuery<
    Schemas.UserPublicRepresentationDTO,
    GetUserByIdError,
    TData
  >({
    ...getUserByIdQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetUserById = <TData = Schemas.UserPublicRepresentationDTO,>(
  variables: GetUserByIdVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.UserPublicRepresentationDTO,
      GetUserByIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApi1Context(options);
  return reactQuery.useQuery<
    Schemas.UserPublicRepresentationDTO,
    GetUserByIdError,
    TData
  >({
    ...getUserByIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetAllUsersPageableQueryParams = {
  /**
   * @format int32
   */
  offset: number;
  /**
   * @format int32
   */
  limit: number;
};

export type GetAllUsersPageableError = Fetcher.ErrorWrapper<undefined>;

export type GetAllUsersPageableResponse = Schemas.UserListRepresentationDTO[];

export type GetAllUsersPageableVariables = {
  queryParams: GetAllUsersPageableQueryParams;
} & Api1Context["fetcherOptions"];

export const fetchGetAllUsersPageable = (
  variables: GetAllUsersPageableVariables,
  signal?: AbortSignal,
) =>
  api1Fetch<
    GetAllUsersPageableResponse,
    GetAllUsersPageableError,
    undefined,
    {},
    GetAllUsersPageableQueryParams,
    {}
  >({ url: "/api/users/page", method: "get", ...variables, signal });

export function getAllUsersPageableQuery(
  variables: GetAllUsersPageableVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetAllUsersPageableResponse>;
};

export function getAllUsersPageableQuery(
  variables: GetAllUsersPageableVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetAllUsersPageableResponse>)
    | reactQuery.SkipToken;
};

export function getAllUsersPageableQuery(
  variables: GetAllUsersPageableVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/users/page",
      operationId: "getAllUsersPageable",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetAllUsersPageable(variables, signal),
  };
}

export const useSuspenseGetAllUsersPageable = <
  TData = GetAllUsersPageableResponse,
>(
  variables: GetAllUsersPageableVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetAllUsersPageableResponse,
      GetAllUsersPageableError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApi1Context(options);
  return reactQuery.useSuspenseQuery<
    GetAllUsersPageableResponse,
    GetAllUsersPageableError,
    TData
  >({
    ...getAllUsersPageableQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetAllUsersPageable = <TData = GetAllUsersPageableResponse,>(
  variables: GetAllUsersPageableVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetAllUsersPageableResponse,
      GetAllUsersPageableError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApi1Context(options);
  return reactQuery.useQuery<
    GetAllUsersPageableResponse,
    GetAllUsersPageableError,
    TData
  >({
    ...getAllUsersPageableQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetFavouriteByKeycloakIdPathParams = {
  id: string;
};

export type GetFavouriteByKeycloakIdError = Fetcher.ErrorWrapper<undefined>;

export type GetFavouriteByKeycloakIdResponse = number[];

export type GetFavouriteByKeycloakIdVariables = {
  pathParams: GetFavouriteByKeycloakIdPathParams;
} & Api1Context["fetcherOptions"];

export const fetchGetFavouriteByKeycloakId = (
  variables: GetFavouriteByKeycloakIdVariables,
  signal?: AbortSignal,
) =>
  api1Fetch<
    GetFavouriteByKeycloakIdResponse,
    GetFavouriteByKeycloakIdError,
    undefined,
    {},
    {},
    GetFavouriteByKeycloakIdPathParams
  >({ url: "/api/users/favourite/{id}", method: "get", ...variables, signal });

export function getFavouriteByKeycloakIdQuery(
  variables: GetFavouriteByKeycloakIdVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetFavouriteByKeycloakIdResponse>;
};

export function getFavouriteByKeycloakIdQuery(
  variables: GetFavouriteByKeycloakIdVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetFavouriteByKeycloakIdResponse>)
    | reactQuery.SkipToken;
};

export function getFavouriteByKeycloakIdQuery(
  variables: GetFavouriteByKeycloakIdVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/users/favourite/{id}",
      operationId: "getFavouriteByKeycloakId",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetFavouriteByKeycloakId(variables, signal),
  };
}

export const useSuspenseGetFavouriteByKeycloakId = <
  TData = GetFavouriteByKeycloakIdResponse,
>(
  variables: GetFavouriteByKeycloakIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetFavouriteByKeycloakIdResponse,
      GetFavouriteByKeycloakIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApi1Context(options);
  return reactQuery.useSuspenseQuery<
    GetFavouriteByKeycloakIdResponse,
    GetFavouriteByKeycloakIdError,
    TData
  >({
    ...getFavouriteByKeycloakIdQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetFavouriteByKeycloakId = <
  TData = GetFavouriteByKeycloakIdResponse,
>(
  variables: GetFavouriteByKeycloakIdVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetFavouriteByKeycloakIdResponse,
      GetFavouriteByKeycloakIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApi1Context(options);
  return reactQuery.useQuery<
    GetFavouriteByKeycloakIdResponse,
    GetFavouriteByKeycloakIdError,
    TData
  >({
    ...getFavouriteByKeycloakIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetFavouriteByKeycloakIdPageablePathParams = {
  id: string;
};

export type GetFavouriteByKeycloakIdPageableQueryParams = {
  /**
   * @format int32
   */
  offset: number;
  /**
   * @format int32
   */
  limit: number;
};

export type GetFavouriteByKeycloakIdPageableError =
  Fetcher.ErrorWrapper<undefined>;

export type GetFavouriteByKeycloakIdPageableResponse = number[];

export type GetFavouriteByKeycloakIdPageableVariables = {
  pathParams: GetFavouriteByKeycloakIdPageablePathParams;
  queryParams: GetFavouriteByKeycloakIdPageableQueryParams;
} & Api1Context["fetcherOptions"];

export const fetchGetFavouriteByKeycloakIdPageable = (
  variables: GetFavouriteByKeycloakIdPageableVariables,
  signal?: AbortSignal,
) =>
  api1Fetch<
    GetFavouriteByKeycloakIdPageableResponse,
    GetFavouriteByKeycloakIdPageableError,
    undefined,
    {},
    GetFavouriteByKeycloakIdPageableQueryParams,
    GetFavouriteByKeycloakIdPageablePathParams
  >({
    url: "/api/users/favourite/v2/{id}",
    method: "get",
    ...variables,
    signal,
  });

export function getFavouriteByKeycloakIdPageableQuery(
  variables: GetFavouriteByKeycloakIdPageableVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetFavouriteByKeycloakIdPageableResponse>;
};

export function getFavouriteByKeycloakIdPageableQuery(
  variables: GetFavouriteByKeycloakIdPageableVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetFavouriteByKeycloakIdPageableResponse>)
    | reactQuery.SkipToken;
};

export function getFavouriteByKeycloakIdPageableQuery(
  variables: GetFavouriteByKeycloakIdPageableVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/users/favourite/v2/{id}",
      operationId: "getFavouriteByKeycloakIdPageable",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetFavouriteByKeycloakIdPageable(variables, signal),
  };
}

export const useSuspenseGetFavouriteByKeycloakIdPageable = <
  TData = GetFavouriteByKeycloakIdPageableResponse,
>(
  variables: GetFavouriteByKeycloakIdPageableVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetFavouriteByKeycloakIdPageableResponse,
      GetFavouriteByKeycloakIdPageableError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApi1Context(options);
  return reactQuery.useSuspenseQuery<
    GetFavouriteByKeycloakIdPageableResponse,
    GetFavouriteByKeycloakIdPageableError,
    TData
  >({
    ...getFavouriteByKeycloakIdPageableQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export const useGetFavouriteByKeycloakIdPageable = <
  TData = GetFavouriteByKeycloakIdPageableResponse,
>(
  variables: GetFavouriteByKeycloakIdPageableVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetFavouriteByKeycloakIdPageableResponse,
      GetFavouriteByKeycloakIdPageableError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApi1Context(options);
  return reactQuery.useQuery<
    GetFavouriteByKeycloakIdPageableResponse,
    GetFavouriteByKeycloakIdPageableError,
    TData
  >({
    ...getFavouriteByKeycloakIdPageableQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetFavouriteCountByKeycloakIdPathParams = {
  id: string;
};

export type GetFavouriteCountByKeycloakIdError =
  Fetcher.ErrorWrapper<undefined>;

export type GetFavouriteCountByKeycloakIdVariables = {
  pathParams: GetFavouriteCountByKeycloakIdPathParams;
} & Api1Context["fetcherOptions"];

export const fetchGetFavouriteCountByKeycloakId = (
  variables: GetFavouriteCountByKeycloakIdVariables,
  signal?: AbortSignal,
) =>
  api1Fetch<
    number,
    GetFavouriteCountByKeycloakIdError,
    undefined,
    {},
    {},
    GetFavouriteCountByKeycloakIdPathParams
  >({
    url: "/api/users/favourite/count/{id}",
    method: "get",
    ...variables,
    signal,
  });

export function getFavouriteCountByKeycloakIdQuery(
  variables: GetFavouriteCountByKeycloakIdVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<number>;
};

export function getFavouriteCountByKeycloakIdQuery(
  variables: GetFavouriteCountByKeycloakIdVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<number>)
    | reactQuery.SkipToken;
};

export function getFavouriteCountByKeycloakIdQuery(
  variables: GetFavouriteCountByKeycloakIdVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/users/favourite/count/{id}",
      operationId: "getFavouriteCountByKeycloakId",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetFavouriteCountByKeycloakId(variables, signal),
  };
}

export const useSuspenseGetFavouriteCountByKeycloakId = <TData = number,>(
  variables: GetFavouriteCountByKeycloakIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      number,
      GetFavouriteCountByKeycloakIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApi1Context(options);
  return reactQuery.useSuspenseQuery<
    number,
    GetFavouriteCountByKeycloakIdError,
    TData
  >({
    ...getFavouriteCountByKeycloakIdQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetFavouriteCountByKeycloakId = <TData = number,>(
  variables: GetFavouriteCountByKeycloakIdVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      number,
      GetFavouriteCountByKeycloakIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApi1Context(options);
  return reactQuery.useQuery<number, GetFavouriteCountByKeycloakIdError, TData>(
    {
      ...getFavouriteCountByKeycloakIdQuery(
        variables === reactQuery.skipToken
          ? variables
          : deepMerge(fetcherOptions, variables),
      ),
      ...options,
      ...queryOptions,
    },
  );
};

export type GetKeycloakIdByEmailPathParams = {
  email: string;
};

export type GetKeycloakIdByEmailError = Fetcher.ErrorWrapper<undefined>;

export type GetKeycloakIdByEmailVariables = {
  pathParams: GetKeycloakIdByEmailPathParams;
} & Api1Context["fetcherOptions"];

export const fetchGetKeycloakIdByEmail = (
  variables: GetKeycloakIdByEmailVariables,
  signal?: AbortSignal,
) =>
  api1Fetch<
    string,
    GetKeycloakIdByEmailError,
    undefined,
    {},
    {},
    GetKeycloakIdByEmailPathParams
  >({ url: "/api/users/email/{email}", method: "get", ...variables, signal });

export function getKeycloakIdByEmailQuery(
  variables: GetKeycloakIdByEmailVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<string>;
};

export function getKeycloakIdByEmailQuery(
  variables: GetKeycloakIdByEmailVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<string>)
    | reactQuery.SkipToken;
};

export function getKeycloakIdByEmailQuery(
  variables: GetKeycloakIdByEmailVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/users/email/{email}",
      operationId: "getKeycloakIdByEmail",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetKeycloakIdByEmail(variables, signal),
  };
}

export const useSuspenseGetKeycloakIdByEmail = <TData = string,>(
  variables: GetKeycloakIdByEmailVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<string, GetKeycloakIdByEmailError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApi1Context(options);
  return reactQuery.useSuspenseQuery<string, GetKeycloakIdByEmailError, TData>({
    ...getKeycloakIdByEmailQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetKeycloakIdByEmail = <TData = string,>(
  variables: GetKeycloakIdByEmailVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<string, GetKeycloakIdByEmailError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApi1Context(options);
  return reactQuery.useQuery<string, GetKeycloakIdByEmailError, TData>({
    ...getKeycloakIdByEmailQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetUserCountError = Fetcher.ErrorWrapper<undefined>;

export type GetUserCountVariables = Api1Context["fetcherOptions"];

export const fetchGetUserCount = (
  variables: GetUserCountVariables,
  signal?: AbortSignal,
) =>
  api1Fetch<number, GetUserCountError, undefined, {}, {}, {}>({
    url: "/api/users/count",
    method: "get",
    ...variables,
    signal,
  });

export function getUserCountQuery(variables: GetUserCountVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<number>;
};

export function getUserCountQuery(
  variables: GetUserCountVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<number>)
    | reactQuery.SkipToken;
};

export function getUserCountQuery(
  variables: GetUserCountVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/users/count",
      operationId: "getUserCount",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetUserCount(variables, signal),
  };
}

export const useSuspenseGetUserCount = <TData = number,>(
  variables: GetUserCountVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<number, GetUserCountError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApi1Context(options);
  return reactQuery.useSuspenseQuery<number, GetUserCountError, TData>({
    ...getUserCountQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetUserCount = <TData = number,>(
  variables: GetUserCountVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<number, GetUserCountError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useApi1Context(options);
  return reactQuery.useQuery<number, GetUserCountError, TData>({
    ...getUserCountQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type QueryOperation =
  | {
      path: "/api/users/favourite/{id}/{favourite}";
      operationId: "isFavourite";
      variables: IsFavouriteVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/users";
      operationId: "getAllUsers";
      variables: GetAllUsersVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/users/{id}";
      operationId: "getUserById";
      variables: GetUserByIdVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/users/page";
      operationId: "getAllUsersPageable";
      variables: GetAllUsersPageableVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/users/favourite/{id}";
      operationId: "getFavouriteByKeycloakId";
      variables: GetFavouriteByKeycloakIdVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/users/favourite/v2/{id}";
      operationId: "getFavouriteByKeycloakIdPageable";
      variables:
        | GetFavouriteByKeycloakIdPageableVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/api/users/favourite/count/{id}";
      operationId: "getFavouriteCountByKeycloakId";
      variables: GetFavouriteCountByKeycloakIdVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/users/email/{email}";
      operationId: "getKeycloakIdByEmail";
      variables: GetKeycloakIdByEmailVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/users/count";
      operationId: "getUserCount";
      variables: GetUserCountVariables | reactQuery.SkipToken;
    };
